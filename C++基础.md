## 程序编译过程(从源文件到可执行文件的过程？)
1. 预处理->hello.i去除注释、展开宏定义，处理预编译指令  
2. 编译>hello.s将预处理的文件进行词法分析、语法分析、语义分析产生汇编代码文件  
3. 汇编->hello.obj把汇编代码翻译成目标机器指令，生成目标文件（包括代码段、数据段）  
4. 链接->hello.out 或hello.exe  
　静态链接：将汇编生成的目标文件.0与引用到的库一起链接打包到可执行文件  
　动态链接：动态库在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布带来麻烦。  

## define和const⽐比较 (const 完全替代 define) 
1. const有数据类型，编译器可以进行类型安全检查；后者只进行字符替换，不计算，不作表达式求解  
2. const有作用域，而define不重视作用域，默认从定义处到文件结尾。

## C++ 中 static 关键字的作用
1. 全局静态变量  
内存中的位置：静态存储区。   
作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。  
2.  局部静态变量  
内存中的位置：静态存储区。  
作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。  
3. 静态函数  
4. 类的静态成员变量    
在类中，静态成员可以实现多个对象之间的数据共享,所有对象共享一份数据。  
静态变量在编译阶段就分配内存，在对象还没有创建时就已经分配空间。  
类内声明，类外初始化。  
5. 类的静态函数   
所有对象共享一个函数  
类的静态函数只能访问静态成员变量。  
