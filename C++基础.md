## 程序编译过程(从源文件到可执行文件的过程？)
1. 预处理->hello.i去除注释、展开宏定义，处理预编译指令  
2. 编译>hello.s将预处理的文件进行词法分析、语法分析、语义分析产生汇编代码文件  
3. 汇编->hello.obj把汇编代码翻译成目标机器指令，生成目标文件（包括代码段、数据段）  
4. 链接->hello.out 或hello.exe  
　静态链接：将汇编生成的目标文件.0与引用到的库一起链接打包到可执行文件  
　动态链接：动态库在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布带来麻烦。  

## define和const⽐比较 (const 完全替代 define) 
1. const有数据类型，编译器可以进行类型安全检查；后者只进行字符替换，不计算，不作表达式求解  
2. const有作用域，而define不重视作用域，默认从定义处到文件结尾。

## C++ 中 static 关键字的作用
1. 全局（局部）静态变量    
存储位置：在静态存储区。  
对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。  
对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义   
2. 静态成员变量（函数）  
static 还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。   
静态成员变量在编译阶段就分配内存。类内声明，类外初始化。    
静态成员函数只能访问静态成员变量。   

## C/C++ 中指针和引用的区别？  
1. 指针有自己的一块空间，而引用只是一个别名；  
2. 使用 sizeof 看一个指针的大小是 4，而引用则是被引用对象的大小；  
3. 指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象的引用；  
4. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；  
5. 指针可以有多级指针，而引用只有一级；  
6. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。  

## C++中的智能指针  
1. 介绍一下智能指针  
智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++ 11 中最常用的智能指针类型为 shared_ptr, 它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。只有引用计数为 0 时，智能指针才会自动释放引用的内存资源。  
2. 智能指针的内存泄露的情况  
当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。   
3. 智能指针的内存泄漏如何解决   
为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。  

## 为什么析构函数必须是虚函数？为什么 C++ 默认的析构函数不是虚函数    
将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们 new 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。  
C++ 默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此 C++ 默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。  
