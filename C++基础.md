## 程序编译过程(从源文件到可执行文件的过程？)
1. 预处理->hello.i去除注释、展开宏定义，处理预编译指令  
2. 编译>hello.s将预处理的文件进行词法分析、语法分析、语义分析产生汇编代码文件  
3. 汇编->hello.obj把汇编代码翻译成目标机器指令，生成目标文件（包括代码段、数据段）  
4. 链接->hello.out 或hello.exe  
　静态链接：将汇编生成的目标文件.0与引用到的库一起链接打包到可执行文件  
　动态链接：动态库在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布带来麻烦。  

## define和const⽐比较 (const 完全替代 define) 
1. const有数据类型，编译器可以进行类型安全检查；后者只进行字符替换，不计算，不作表达式求解  
2. const有作用域，而define不重视作用域，默认从定义处到文件结尾。

## C++ 中 static 关键字的作用
1. 全局（局部）静态变量    
存储位置：在静态存储区。  
对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。  
对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义   
2. 静态成员变量（函数）  
static 还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。   
静态成员变量在编译阶段就分配内存。类内声明，类外初始化。    
静态成员函数只能访问静态成员变量。   

## C/C++ 中指针和引用的区别？  
1. 指针有自己的一块空间，而引用只是一个别名；  
2. 使用 sizeof 看一个指针的大小是 4，而引用则是被引用对象的大小；  
3. 指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象的引用；  
4. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；  
5. 指针可以有多级指针，而引用只有一级；  
6. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。  

## C++中的智能指针  
1. 介绍一下智能指针  
智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++ 11 中最常用的智能指针类型为 shared_ptr, 它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。只有引用计数为 0 时，智能指针才会自动释放引用的内存资源。  
2. 智能指针的内存泄露的情况  
当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。   
3. 智能指针的内存泄漏如何解决   
为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。  

## 为什么析构函数必须是虚函数？为什么 C++ 默认的析构函数不是虚函数    
将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们 new 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。  
C++ 默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此 C++ 默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。 

## volatile关键字  
volatile关键字是一种限定符用来声明一个对象在程序中可以被语句外的东西修改,比如操作系统、硬件或并发执行线程。遇到该关键字，**编译器不再对该变量的代码进行优化，不再从寄存器中读取变量的值，而是直接从它所在的内存中读取值**，即使它前面的指令刚刚从该处读取过数据。  
**多线程下的volatile**：当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。  

## inline内联函数
当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用. 当函数体比较小的时候, 内联该函数可以令目标代码更加高效.   
与宏定义的区别：**内联函数可以进行类型检查和调试**。  

## new与malloc的区别  
1、malloc与free是c++/c语言的标准函数，new/delete是C++的运算符。  
2、new和delete**在对象创建的时候自动执行构造函数，对象消亡之前会自动执行析构函数**。  
3、new返回指定类型的指针，并且可以自动计算出所需要的大小。malloc必须用户指定大小，并且默然返回类型为void*,必须强行转换为实际类型的指针。  

## c++进程内存空间分布
内存分布分为5个部分，从高地址到低地址一次为 **栈区（地址增长由高到低）**，堆区（heap），未初始化数据段（uninitialized data），初始化数据段（initialize data），代码段（text）。

## 深拷贝与浅拷贝
当调用对象的拷贝构造函数时，会有深拷贝与浅拷贝两种形式。
浅拷贝：默认拷贝构造函数为浅拷贝，**多个对象共用同一块资源**，同一块资源释放多次，崩溃或者内存泄漏
深拷贝：每个对象共同拥有自己的资源，必须**显式提供拷贝构造函数**和赋值运算符。

